import { ListState } from './state';
import { Iterable } from '../shared/common';
export declare type ListMutationCallback<T> = (list: PersistentList<T>) => void;
export declare type UpdateCallback<T> = (value: T | undefined) => T;
export declare class PersistentList<T> implements Iterable<T> {
    _state: ListState<T>;
    static empty<T>(): PersistentList<T>;
    static fromArray<T>(values: T[]): PersistentList<T>;
    constructor(_state: ListState<T>);
    readonly size: number;
    readonly mutable: boolean;
    hasIndex(index: number): boolean;
    hasIn(path: any[]): boolean;
    batch(callback: ListMutationCallback<T>): PersistentList<T>;
    asMutable(): PersistentList<T>;
    asImmutable(): PersistentList<T>;
    freeze(): PersistentList<T>;
    thaw(): PersistentList<T>;
    update(index: number, callback: UpdateCallback<T>): PersistentList<T>;
    get(index: number): T | undefined;
    getIn(path: any[]): any | undefined;
    set(index: number, value: T): PersistentList<T>;
    setIn(path: any[], value: any): PersistentList<T>;
    append(...values: T[]): PersistentList<T>;
    appendArray(values: T[]): PersistentList<T>;
    prepend(...values: T[]): PersistentList<T>;
    prependArray(values: T[]): PersistentList<T>;
    insert(index: number, ...values: T[]): PersistentList<T>;
    insertArray(index: number, values: T[]): PersistentList<T>;
    delete(index: number): PersistentList<T>;
    deleteRange(start: number, end: number): PersistentList<T>;
    pop(): PersistentList<T>;
    popFront(): PersistentList<T>;
    skip(count: number): PersistentList<T>;
    take(count: number): PersistentList<T>;
    slice(start: number, end?: number): PersistentList<T>;
    concat(...lists: PersistentList<T>[]): PersistentList<T>;
    toArray(): T[];
    [Symbol.iterator](): IterableIterator<T | undefined>;
    values(): IterableIterator<T | undefined>;
    toJS(): T[];
}
export declare function isDefaultEmptyList(list: PersistentList<any>): boolean;
export declare var _emptyList: PersistentList<any>;
