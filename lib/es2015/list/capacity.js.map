{"version":3,"sources":["../lib/ts/list/capacity.ts"],"names":[],"mappings":";AAAA,mDAAwC;AACxC,qCAAqF;AACrF,2CAAuC;AACvC,iCAAiD;AACjD,iCAA4B;AAC5B,mCAA2C;AAE3C;IAoBE;QAJA,aAAQ,GAAoB,KAAK,CAAC,CAAC;QACnC,UAAK,GAAG,CAAC,CAAC;QACV,WAAM,GAAG,CAAC,CAAC;IAEY,CAAC;IAjBxB,MAAM,CAAC,OAAO,CAAI,KAAa,EAAE,OAAgB;QAC/C,IAAI,CAAC,GAAG,SAAS,CAAC,QAAQ,CAAC;QAC3B,CAAC,CAAC,QAAQ,GAAG,IAAI,KAAK,CAAM,KAAK,CAAC,CAAC;QACnC,CAAC,CAAC,KAAK,GAAG,OAAO,GAAG,KAAK,GAAG,CAAC,CAAC;QAC9B,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;IAED,MAAM,CAAC,GAAG,CAAI,QAAa;QACzB,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;QACtB,CAAC,CAAC,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC;QACxB,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;IAQD,GAAG,CAAC,QAAa;QACf,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;QACrC,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;IAED,IAAI;QACF,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;IAC3B,CAAC;IAED,OAAO;QACL,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;IAC3B,CAAC;IAED,QAAQ,CAAC,MAAW,EAAE,UAAkB;QACtC,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC7B,GAAG,CAAA,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,UAAU,GAAG,CAAC,EAAE,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EACjE,CAAC,EAAE,EAAE,UAAU,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,EAAE,KAAK,GAAG,QAAQ,CAAC,EAAE,UAAU,CAAC,CAAC,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE,CAAC;YAC5G,KAAK,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QAChC,CAAC;QACD,IAAI,CAAC,QAAQ,GAAQ,KAAK,CAAC,CAAC;IAC9B,CAAC;;AAzCc,kBAAQ,GAAG,IAAI,SAAS,EAAO,CAAC;AADjD,8BA2CC;AAgBD,0BAAoC,KAAmB,EAAE,UAAkB,EAAE,OAAgB;IAC3F,IAAI,IAAI,GAAG,OAAO,GAAG,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC;IAC9C,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACrB,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;IACxB,IAAI,kBAAkB,GAAG,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IAE5E,KAAK,CAAC,IAAI,IAAI,kBAAkB,CAAC;IAEjC,EAAE,CAAA,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;QAChC,eAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACvB,CAAC;IAGD,EAAE,CAAA,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;QAC1B,EAAE,CAAA,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1B,IAAI,CAAC,WAAW,CAAC,OAAO,GAAG,kBAAkB,GAAG,CAAC,EAAE,OAAO,GAAG,CAAC,GAAG,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAC7F,CAAC;QACD,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,KAAK,GAAG,KAAK,EAAE,OAAO,GAAG,kBAAkB,GAAG,CAAC,EAAE,OAAO,GAAG,CAAC,GAAG,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAC/J,CAAC;QAGD,EAAE,CAAA,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YAClB,IAAI,CAAC,SAAS,IAAI,kBAAkB,CAAC;YACrC,IAAI,CAAC,UAAU,IAAI,kBAAkB,CAAC;QACxC,CAAC;QAGD,EAAE,CAAA,CAAC,kBAAkB,KAAK,UAAU,CAAC,CAAC,CAAC;YACrC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAS,IAAI,CAAC,KAAK,CAAC,CAAC;QAC3C,CAAC;IACH,CAAC;IAED,MAAM,CAAC,qBAAqB,CAAC,KAAK,EAAE,UAAU,EAAE,kBAAkB,EAAE,OAAO,CAAC,CAAC;AAC/E,CAAC;AAnCD,4CAmCC;AAED,+BAAkC,KAAmB,EAAE,UAAkB,EAAE,kBAA0B,EAAE,OAAgB;IACrH,IAAI,IAAI,GAAG,OAAO,GAAG,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC;IAC9C,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IAIrB,IAAI,SAAS,GAAG,SAAS,CAAC,OAAO,CAAI,CAAC,kBAAkB,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,yBAAgB,CAAC,UAAU,GAAG,kBAAkB,EAAE,CAA2B,CAAC,EAAE,OAAO,CAAC,CAAC;IACjK,EAAE,CAAA,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;QAC1B,EAAE,CAAA,CAAC,OAAO,CAAC,CAAC,CAAC;YACX,SAAS,CAAC,KAAK,EAAE,CAAC;YAClB,SAAS,CAAC,IAAI,EAAE,CAAC;QACnB,CAAC;QACD,SAAS,CAAC,GAAG,CAAM,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/B,EAAE,CAAA,CAAC,OAAO,CAAC,CAAC,CAAC;YACX,SAAS,CAAC,OAAO,EAAE,CAAC;QACtB,CAAC;IACH,CAAC;IAKD,IAAI,MAAM,GAAG,0BAAmB,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC9C,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC;IACzB,IAAI,aAAa,GAAG,UAAU,GAAG,kBAAkB,CAAC;IACpD,IAAI,MAAM,GAAG,sBAAU,CAAC,cAAc,EAAK,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK,EAAE,CAAqB,CAAC,CAAC;IAOnG,GAAG,CAAC;QACF,KAAK,IAAI,CAA2B,CAAC;QACrC,kBAAkB,GAAG,mBAAmB,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,EAAE,yBAAgB,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC,CAAC;QAC9H,MAAM,CAAC,SAAS,GAAG,eAAG,CAAC,aAAa,EAAE,kBAAkB,IAAI,KAAK,CAAC,CAAC;QACnE,aAAa,IAAI,MAAM,CAAC,SAAS,CAAC;QAClC,EAAE,CAAA,CAAC,OAAO,CAAC,CAAC,CAAC;YACX,MAAM,CAAC,OAAO,GAAG,kBAAkB,CAAC;QACtC,CAAC;QACD,IAAI,CAAC,CAAC;YACJ,MAAM,CAAC,QAAQ,GAAG,kBAAkB,CAAC;QACvC,CAAC;QAED,IAAI,UAAU,GAAG,MAAM,CAAC,YAAY,EAAE,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,GAAG,CAAmB,GAAG,CAA2B,CAAC;QAC9I,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;QAEzC,EAAE,CAAA,CAAC,kBAAkB,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,MAAM,KAAK,CAAkB,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,IAAI,CAAC,MAAM,KAAK,CAAmB,CAAC,CAAC,CAAC,CAAC;YAC9H,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC;QAED,EAAE,CAAA,CAAC,OAAO,CAAC,CAAC,CAAC;YACX,SAAS,CAAC,KAAK,IAAI,yBAAgB,CAAC,MAAM,CAAC,SAAS,EAAE,CAA2B,CAAC,CAAC;YACnF,SAAS,CAAC,IAAI,EAAE,CAAC;QACnB,CAAC;QAED,KAAK,EAAE,CAAC;QACR,EAAE,CAAA,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;YAC1B,gBAAgB,CAAC,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,EAC5C,OAAO,GAAG,CAAC,kBAAkB,GAAG,IAAI,CAAC,SAAS,EAAE,GAAG,kBAAkB,EACrE,MAAM,CAAC,SAAS,GAAG,aAAa,EAAE,aAAa,KAAK,CAAC,CAAC,CAAC;YACzD,EAAE,CAAA,CAAC,OAAO,CAAC,CAAC,CAAC;gBACX,SAAS,CAAC,OAAO,EAAE,CAAC;YACtB,CAAC;QACH,CAAC;IAEH,CAAC,QAAO,aAAa,GAAG,CAAC,EAAE;IAE3B,EAAE,CAAA,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACjB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;IACtB,CAAC;IAED,MAAM,CAAC,OAAO,EAAE,CAAC;IAEjB,MAAM,CAAC,SAAS,CAAC;AACnB,CAAC;AAeD,0BAA6B,KAAmB,EAAE,SAAuB,EAAE,IAAa,EAAE,aAAqB,EAAE,iBAAyB,EAAE,QAAgB,EAAE,YAAqB;IACjL,IAAI,UAAU,GAAG,aAAa,GAAG,CAAC,CAAC;IACnC,IAAI,SAAS,GAAG,QAAQ,CAAC;IACzB,IAAI,KAAK,GAAG,CAA2B,GAAG,aAAa,CAAC;IACxD,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACrB,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;IACvB,IAAI,OAAO,GAAG,iBAAiB,GAAG,CAAC,CAAC;IACpC,IAAI,SAAS,GAAG,OAAO,GAAG,CAAC,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IACjE,IAAI,SAAS,GAAG,OAAO,GAAG,CAAC,GAAG,iBAAiB,CAAC;IAChD,IAAI,WAAW,GAAG,IAAI,KAAK,CAAS,aAAa,CAAC,CAAC;IACnD,IAAI,UAAU,GAAG,IAAI,KAAK,CAAS,aAAa,CAAC,CAAC;IAClD,IAAI,QAAQ,GAAG,IAAI,KAAK,CAAU,aAAa,CAAC,CAAC;IACjD,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;IACxB,IAAI,KAAK,GAAG,CAAC,EAAE,QAAQ,GAAG,CAAC,CAAC;IAC5B,IAAI,MAAe,CAAC;IAEpB,WAAW,CAAC,UAAU,CAAC,GAAG,SAAS,CAAC;IACpC,UAAU,CAAC,UAAU,CAAC,GAAG,SAAS,CAAC;IACnC,QAAQ,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;IAE5B,GAAG,CAAC;QAGF,EAAE,CAAA,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC,CAAC;YAC3B,MAAM,GAAG,YAAY,IAAI,CAAC,CAAC,OAAO,IAAI,SAAS,KAAK,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,UAAU,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC;YAC7I,EAAE,CAAA,CAAC,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC;gBACpB,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC;YAC5B,CAAC;YAED,UAAU,EAAE,CAAC;YAEb,EAAE,CAAA,CAAC,UAAU,GAAG,aAAa,CAAC,CAAC,CAAC;gBAC9B,SAAS,GAAG,EAAE,WAAW,CAAC,UAAU,CAAC,CAAC;gBACtC,QAAQ,GAAG,SAAS,CAAC;gBACrB,SAAS,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC;gBACnC,KAAK,IAAI,CAA2B,CAAC;gBACrC,IAAI,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC;gBAC5B,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC;gBAC1B,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACrB,CAAC;QACH,CAAC;QAGD,IAAI,CAAC,CAAC;YAGJ,EAAE,CAAA,CAAC,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC;gBACpB,MAAM,GAAG,YAAY,IAAI,CAAC,CAAC,OAAO,IAAI,QAAQ,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,SAAS,IAAI,EAAmB,CAAC,CAAC,CAAC;gBACjH,IAAI,YAAY,GAAG,MAAM,GAAG,CAAC,SAAS,GAAG,EAAuB,CAAC,IAAI,EAAmB,GAAG,eAAG,CAAC,SAAS,EAAE,EAAmB,CAAC,CAAC;gBAC/H,IAAI,SAAS,GAAG,IAAI,KAAK,CAAI,YAAY,CAAC,CAAC;gBAC3C,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBACzB,IAAI,QAAQ,GAAG,IAAI,WAAI,CAAI,KAAK,EAAE,YAAY,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;gBACrE,KAAK,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC;gBAE5B,EAAE,CAAA,CAAC,MAAM,CAAC,CAAC,CAAC;oBACV,EAAE,CAAA,CAAC,OAAO,IAAI,YAAY,GAAG,EAAmB,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;wBACrE,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;oBACzC,CAAC;oBACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;oBAChE,IAAI,GAAG,WAAI,CAAC,MAAM,CAAI,KAAK,EAAE,CAAC,EAAE,OAAO,GAAG,CAAkB,GAAG,CAAmB,EAAE,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;oBACrH,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,KAAK,CAAC;oBACzB,eAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;gBACvB,CAAC;gBAED,SAAS,IAAI,YAAY,CAAC;gBAC1B,KAAK,IAAI,YAAY,CAAC;gBACtB,QAAQ,IAAI,YAAY,CAAC;gBACzB,SAAS,EAAE,CAAC;YACd,CAAC;YAGD,IAAI,CAAC,CAAC;gBACJ,MAAM,GAAG,YAAY,IAAI,CAAC,CAAC,OAAO,IAAI,QAAQ,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,SAAS,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC5I,KAAK,IAAI,CAA2B,CAAC;gBACrC,KAAK,GAAG,CAAC,CAAC;gBACV,QAAQ,GAAG,CAAC,CAAC;gBACb,UAAU,EAAE,CAAC;gBACb,IAAI,IAAI,GAAG,MAAM,IAAI,eAAM,CAAC,SAAS,EAAE,KAAK,CAAC,IAAI,eAAG,CAAC,SAAS,EAAE,EAAmB,IAAI,KAAK,CAAC,CAAC;gBAC9F,EAAE,CAAA,CAAC,OAAO,IAAI,MAAM,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,GAAG,EAAmB,IAAI,KAAK,CAAC,CAAC,CAAC;oBAChF,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC;gBAChC,CAAC;gBACD,SAAS,GAAG,yBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC1C,IAAI,GAAG,IAAI,WAAI,CAAI,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,KAAK,CAAI,SAAS,CAAC,CAAC,CAAC;gBACnE,QAAQ,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;gBAC5B,EAAE,CAAA,CAAC,MAAM,CAAC,CAAC,CAAC;oBACV,IAAI,GAAG,WAAI,CAAC,MAAM,CAAI,KAAK,EAAE,CAAC,EAAE,OAAO,GAAG,CAAkB,GAAG,CAAmB,EAAE,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;oBACjH,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;oBAClD,IAAI,CAAC,KAAK,GAAG,CAAC,KAAK,CAAC;gBACtB,CAAC;gBACD,IAAI,CAAC,CAAC;oBACJ,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC;gBAC1B,CAAC;gBACD,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;gBACnB,UAAU,CAAC,UAAU,CAAC,GAAG,SAAS,CAAC;gBACnC,SAAS,GAAG,CAAC,CAAC;gBACd,WAAW,CAAC,UAAU,CAAC,GAAG,SAAS,CAAC;YACtC,CAAC;QACH,CAAC;IACH,CAAC,QAAO,UAAU,GAAG,aAAa,EAAE;AACtC,CAAC;AAED,6BAA6B,gBAAwB,EAAE,oBAA4B;IACjF,MAAM,CAAC,eAAG,CAAC,EAAmB,GAAG,gBAAgB,EAAE,oBAAoB,CAAC,CAAC;AAC3E,CAAC","file":"capacity.js","sourcesContent":["import {min} from '../shared/functions';\nimport {CONST, COMMIT_MODE, OFFSET_ANCHOR, modulo, shiftDownRoundUp} from './common';\nimport {TreeWorker} from './traversal';\nimport {Slot, ExpansionParameters} from './slot';\nimport {View} from './view';\nimport {ListState, setView} from './state';\n\nexport class Collector<T> {\n  private static _default = new Collector<any>();\n\n  static default<T>(count: number, prepend: boolean) {\n    var c = Collector._default;\n    c.elements = new Array<T[]>(count);\n    c.index = prepend ? count : 0;\n    return c;\n  }\n\n  static one<T>(elements: T[]): Collector<T> {\n    var c = this._default;\n    c.elements = [elements];\n    return c;\n  }\n\n  elements: Array<T[]> = <any>void 0;\n  index = 0;\n  marker = 0;\n\n  private constructor() {}\n\n  set(elements: T[]): void {\n    this.elements[this.index] = elements;\n    this.index++;\n  }\n\n  mark() {\n    this.marker = this.index;\n  }\n\n  restore() {\n    this.index = this.marker;\n  }\n\n  populate(values: T[], innerIndex: number): void {\n    var elements = this.elements;\n    for(var i = 0, outerIndex = 0, inner = elements[0]; i < values.length;\n        i++, innerIndex >= inner.length - 1 ? (innerIndex = 0, inner = elements[++outerIndex]) : (++innerIndex)) {\n      inner[innerIndex] = values[i];\n    }\n    this.elements = <any>void 0;\n  }\n}\n\n/**\n * Increases the capacity of the list by appending or prepending additional slots/nodes. An array of arrays is returned,\n * one per added or updated leaf node, ready for population with values to be added to the list.\n *\n * @export\n * @template T The type of elements present in the list\n * @param {ListState<T>} state The list state to be modified\n * @param {number} increaseBy The additional capacity to add to the list\n * @param {boolean} prepend true if the capacity should be added to the front of the list\n * @returns {T[][]} An array of leaf node element arrays (one per leaf node, in left-to-right sequential order) to which\n *     values should be written to populate the additional list capacity. The first (if appending) or last array (if\n *     prepending) will be a reference to a pre-existing head or tail leaf node element array if that node was expanded\n *     with additional elements as part of the operation.\n */\nexport function increaseCapacity<T>(state: ListState<T>, increaseBy: number, prepend: boolean): Collector<T> {\n  var view = prepend ? state.left : state.right;\n  var slot = view.slot;\n  var group = state.group;\n  var numberOfAddedSlots = calculateSlotsToAdd(slot.slots.length, increaseBy);\n\n  state.size += numberOfAddedSlots;\n\n  if(!view.isEditable(group)) {\n    view = view.cloneToGroup(group);\n    setView(state, view);\n  }\n\n  // If the leaf node was already full, it does not need to be modified.\n  if(numberOfAddedSlots > 0) {\n    if(slot.isEditable(group)) {\n      slot.adjustRange(prepend ? numberOfAddedSlots : 0, prepend ? 0 : numberOfAddedSlots, true);\n    }\n    else {\n      view.slot = slot = slot.cloneWithAdjustedRange(slot.isReserved() ? -group : group, prepend ? numberOfAddedSlots : 0, prepend ? 0 : numberOfAddedSlots, true);\n    }\n\n    // The changes to the size of the leaf node need to be propagated to its parent the next time the tree is ascended.\n    if(!view.isRoot()) {\n      view.sizeDelta += numberOfAddedSlots;\n      view.slotsDelta += numberOfAddedSlots;\n    }\n\n    // If the leaf node had sufficient room for the additional requested capacity, then we're done.\n    if(numberOfAddedSlots === increaseBy) {\n      return Collector.one<T>(<T[]>slot.slots);\n    }\n  }\n\n  return increaseUpperCapacity(state, increaseBy, numberOfAddedSlots, prepend);\n}\n\nfunction increaseUpperCapacity<T>(state: ListState<T>, increaseBy: number, numberOfAddedSlots: number, prepend: boolean): Collector<T> {\n  var view = prepend ? state.left : state.right;\n  var slot = view.slot;\n\n  // An array will be used to collect the list element arrays of all the leaf nodes to be populated by the caller.\n  // var nextElementsIndex = 0;\n  var collector = Collector.default<T>((numberOfAddedSlots > 0 ? 1 : 0) + shiftDownRoundUp(increaseBy - numberOfAddedSlots, CONST.BRANCH_INDEX_BITCOUNT), prepend);\n  if(numberOfAddedSlots > 0) {\n    if(prepend) {\n      collector.index--;\n      collector.mark();\n    }\n    collector.set(<T[]>slot.slots);\n    if(prepend) {\n      collector.restore();\n    }\n  }\n\n  // The ascend function is capable of expanding the parent slot during ascension. An expansion argument is provided and\n  // updated with output values by the ascend function to allow the calling function to keep track of what was changed.\n  // var expand = ExpansionState.reset(state.size, increaseBy - numberOfAddedSlots, 0, prepend);\n  var expand = ExpansionParameters.get(0, 0, 0);\n  var shift = 0, level = 0;\n  var remainingSize = increaseBy - numberOfAddedSlots;\n  var worker = TreeWorker.defaultPrimary<T>().reset(state, view, state.group, COMMIT_MODE.NO_CHANGE);\n\n  // Starting with the head or tail, ascend to each node along the edge, expanding any nodes with additional slots until\n  // the requested capacity has been added. At each level, the additional slots are populated with a subtree of the\n  // appropriate size and depth, and the value arrays for added leaf nodes are saved to the `nodes` array for population\n  // of list element values by the calling function. If the root is reached and additional capacity is still required,\n  // additional nodes are added above the root, increasing the depth of the tree.\n  do {\n    shift += CONST.BRANCH_INDEX_BITCOUNT;\n    numberOfAddedSlots = calculateSlotsToAdd(view.isRoot() ? 1 : view.parent.slotCount(), shiftDownRoundUp(remainingSize, shift));\n    expand.sizeDelta = min(remainingSize, numberOfAddedSlots << shift);\n    remainingSize -= expand.sizeDelta;\n    if(prepend) {\n      expand.padLeft = numberOfAddedSlots;\n    }\n    else {\n      expand.padRight = numberOfAddedSlots;\n    }\n\n    var ascendMode = worker.hasOtherView() && worker.other.slot.isReserved() && view.isRoot() ? COMMIT_MODE.RESERVE : COMMIT_MODE.RELEASE_DISCARD;\n    view = worker.ascend(ascendMode, expand);\n\n    if(numberOfAddedSlots && (prepend && view.anchor === OFFSET_ANCHOR.LEFT) || (!prepend && view.anchor === OFFSET_ANCHOR.RIGHT)) {\n      view.flipAnchor(state.size);\n    }\n\n    if(prepend) {\n      collector.index -= shiftDownRoundUp(expand.sizeDelta, CONST.BRANCH_INDEX_BITCOUNT);\n      collector.mark();\n    }\n\n    level++;\n    if(numberOfAddedSlots > 0) {\n      populateSubtrees(state, collector, view, level,\n        prepend ? -numberOfAddedSlots : view.slotCount() - numberOfAddedSlots,\n        expand.sizeDelta + remainingSize, remainingSize === 0);\n      if(prepend) {\n        collector.restore();\n      }\n    }\n\n  } while(remainingSize > 0);\n\n  if(view.isRoot()) {\n    view.sizeDelta = 0;\n    view.slotsDelta = 0;\n  }\n\n  worker.dispose();\n\n  return collector;\n}\n\n/**\n * Populates a set of expanded node slots with subtrees.\n *\n * @template T\n * @param {View<T>[]} viewPath An array of views; one per level, starting with a leaf node and ending at the current subtree root\n * @param {T[][]} nodes An array of leaf node element arrays to be updated as leaf nodes are added to each subtree\n * @param {number} nodeIndex The next index that should be assigned to in the `nodes` array\n * @param {number} level The level of the subtree root being populated\n * @param {number} slotIndexBoundary A positive number indicates the first slot to be populated during an append\n *     operation. A negative number indicates the upper slot bound (exclusive) to use during a prepend operation.\n * @param {number} remaining The total capacity represented by this set of subtrees\n * @returns {number} An updated `nodeIndex` value to be used in subsequent subtree population operations\n */\nfunction populateSubtrees<T>(state: ListState<T>, collector: Collector<T>, view: View<T>, topLevelIndex: number, slotIndexBoundary: number, capacity: number, isFinalStage: boolean): void {\n  var levelIndex = topLevelIndex - 1;\n  var remaining = capacity;\n  var shift = CONST.BRANCH_INDEX_BITCOUNT * topLevelIndex;\n  var slot = view.slot;\n  var slots = slot.slots;\n  var prepend = slotIndexBoundary < 0;\n  var slotCount = prepend ? -slotIndexBoundary : slot.slots.length;\n  var slotIndex = prepend ? 0 : slotIndexBoundary;\n  var slotIndices = new Array<number>(topLevelIndex);\n  var slotCounts = new Array<number>(topLevelIndex);\n  var slotPath = new Array<Slot<T>>(topLevelIndex);\n  var group = state.group;\n  var delta = 0, subcount = 0;\n  var isEdge: boolean;\n\n  slotIndices[levelIndex] = slotIndex;\n  slotCounts[levelIndex] = slotCount;\n  slotPath[levelIndex] = slot;\n\n  do {\n    // If the current subtree is fully populated, ascend to the next tree level to populate the next adjacent subtree.\n    // The last slot at each level should be reserved for writing when remaining capacity to add reaches zero.\n    if(slotIndex === slotCount) {\n      isEdge = isFinalStage && ((prepend && remaining === capacity - slot.size) || (remaining === 0 && (!prepend || levelIndex >= topLevelIndex)));\n      if(levelIndex === 0) {\n        slot.subcount += subcount;\n      }\n\n      levelIndex++;\n\n      if(levelIndex < topLevelIndex) {\n        slotIndex = ++slotIndices[levelIndex];\n        subcount = slotCount;\n        slotCount = slotCounts[levelIndex];\n        shift += CONST.BRANCH_INDEX_BITCOUNT;\n        slot = slotPath[levelIndex];\n        slot.subcount += subcount;\n        slots = slot.slots;\n      }\n    }\n\n    // Create new slots for each unpopulated slot index in the current node, and recursively descend and populate them\n    else {\n\n      // If we're currently at leaf parent level, just populate the leaf nodes, then ascend when done\n      if(levelIndex === 0) {\n        isEdge = isFinalStage && ((prepend && capacity === remaining) || (!prepend && remaining <= CONST.BRANCH_FACTOR));\n        var elementCount = isEdge ? (remaining & CONST.BRANCH_INDEX_MASK) || CONST.BRANCH_FACTOR : min(remaining, CONST.BRANCH_FACTOR);\n        var leafSlots = new Array<T>(elementCount);\n        collector.set(leafSlots);\n        var leafSlot = new Slot<T>(group, elementCount, 0, -1, 0, leafSlots);\n        slots[slotIndex] = leafSlot;\n\n        if(isEdge) {\n          if(prepend && elementCount < CONST.BRANCH_FACTOR && slots.length > 1) {\n            view.slot.recompute = view.slotCount();\n          }\n          view.slot.slots[slotIndex] = leafSlot.cloneAsPlaceholder(group);\n          view = View.create<T>(group, 0, prepend ? OFFSET_ANCHOR.LEFT : OFFSET_ANCHOR.RIGHT, slotIndex, 0, 0, view, leafSlot);\n          view.slot.group = -group;\n          setView(state, view);\n        }\n\n        remaining -= elementCount;\n        delta += elementCount;\n        subcount += elementCount;\n        slotIndex++;\n      }\n\n      // Descend and populate the subtree of the current slot at this level\n      else {\n        isEdge = isFinalStage && ((prepend && capacity === remaining) || (!prepend && slotIndex === slots.length - 1 && remaining <= (1 << shift)));\n        shift -= CONST.BRANCH_INDEX_BITCOUNT;\n        delta = 0;\n        subcount = 0;\n        levelIndex--;\n        var size = isEdge && modulo(remaining, shift) || min(remaining, CONST.BRANCH_FACTOR << shift);\n        if(prepend && isEdge && slots.length > 1 && size < CONST.BRANCH_FACTOR << shift) {\n          slot.recompute = slots.length;\n        }\n        slotCount = shiftDownRoundUp(size, shift);\n        slot = new Slot<T>(group, size, 0, -1, 0, new Array<T>(slotCount));\n        slotPath[levelIndex] = slot;\n        if(isEdge) {\n          view = View.create<T>(group, 0, prepend ? OFFSET_ANCHOR.LEFT : OFFSET_ANCHOR.RIGHT, slotIndex, 0, 0, view, slot);\n          slots[slotIndex] = slot.cloneAsPlaceholder(group);\n          slot.group = -group;\n        }\n        else {\n          slots[slotIndex] = slot;\n        }\n        slots = slot.slots;\n        slotCounts[levelIndex] = slotCount;\n        slotIndex = 0;\n        slotIndices[levelIndex] = slotIndex;\n      }\n    }\n  } while(levelIndex < topLevelIndex);\n}\n\nfunction calculateSlotsToAdd(initialSlotCount: number, totalAdditionalSlots: number): number {\n  return min(CONST.BRANCH_FACTOR - initialSlotCount, totalAdditionalSlots);\n}\n"]}