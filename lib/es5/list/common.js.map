{"version":3,"sources":["../lib/ts/list/common.ts"],"names":[],"mappings":";AACA,iDAA6C;AA0C7C,sBAA6B,MAAc,EAAE,QAAgB,EAAE,QAAgB;IAC7E,MAAM,CAAC,QAAQ,GAAG,MAAM,GAAG,QAAQ,CAAC;AACtC,CAAC;AAFD,oCAEC;AAED,sBAA6B,MAAqB;IAChD,MAAM,CAAC,MAAM,KAAK,CAAmB,GAAG,CAAkB,GAAG,CAAmB,CAAC;AACnF,CAAC;AAFD,oCAEC;AAED,qBAA4B,IAAY,EAAE,KAAa;IACrD,KAAK,GAAG,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACpC,MAAM,CAAC,KAAK,KAAK,IAAI,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC;AACrC,CAAC;AAHD,kCAGC;AAED,wBAA+B,IAAY,EAAE,KAAa;IACxD,MAAM,CAAC,eAAG,CAAC,CAAC,CAAC,EAAE,eAAG,CAAC,IAAI,EAAE,KAAK,GAAG,CAAC,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC;AAC9D,CAAC;AAFD,wCAEC;AAED,0BAAiC,KAAa,EAAE,KAAa;IAC3D,IAAI,CAAC,GAAG,KAAK,KAAK,KAAK,CAAC;IACxB,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5C,CAAC;AAHD,4CAGC;AAED,gBAAuB,KAAa,EAAE,KAAa;IACjD,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,EAAmB,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AACtD,CAAC;AAFD,wBAEC;AAED,+BAAyC,IAAe,EAAE,KAAgB;IACxE,IAAI,GAAG,GAAG,IAAI,KAAK,CAAU,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;IACzD,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,GAAG,CAAA,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACpC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACjB,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IACD,GAAG,CAAA,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC;QAC1C,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAClB,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;IACD,MAAM,CAAC,GAAG,CAAC;AACb,CAAC;AAZD,sDAYC","file":"common.js","sourcesContent":["import {Slot} from './slot';\nimport {min, max} from '../shared/functions';\n\nexport const enum CONST {\n  // Branch factor means the number of slots (branches) that each node can contain (2^5=32). Each level of the tree\n  // represents a different order of magnitude (base 32) of a given index in the list. The branch factor bit count and\n  // mask are used to isolate each different order of magnitude (groups of 5 bits in the binary representation of a\n  // given list index) in order to descend the tree to the leaf node containing the value at the specified index.\n  BRANCH_INDEX_BITCOUNT = 5,\n  BRANCH_FACTOR = 1 << BRANCH_INDEX_BITCOUNT,\n  BRANCH_INDEX_MASK = BRANCH_FACTOR - 1,\n  MAX_OFFSET_ERROR = (BRANCH_INDEX_BITCOUNT >>> 2) + 1, // `e` in the RRB paper\n}\n\n/**\n * An offset value is relative to either the left or the right of the list. Flipping the offset and anchor of an\n * intermediate view can allow the referenced node to be size-adjusted without affecting the offset values of other\n * views.\n *\n * @export\n * @enum {number}\n */\nexport const enum OFFSET_ANCHOR {\n  LEFT = 0,\n  RIGHT = 1\n}\n\nexport const enum COMMIT_MODE {\n  NO_CHANGE = 0,\n  RESERVE = 1,\n  RELEASE = 2,\n  RELEASE_DISCARD = 3,\n}\n\n/**\n * Flips an inward-facing offset value so that it is equal to the distance from the other end of the list to the\n * opposite bound of a given slot\n *\n * @param {number} offset The original internal offset value, relative to one end of the list\n * @param {number} slotSize The size of the slot that the offset is relative to\n * @param {number} listSize The size of the list\n * @returns {number} The inverted offset value\n */\nexport function invertOffset(offset: number, slotSize: number, listSize: number): number {\n  return listSize - offset - slotSize;\n}\n\nexport function invertAnchor(anchor: OFFSET_ANCHOR): OFFSET_ANCHOR {\n  return anchor === OFFSET_ANCHOR.RIGHT ? OFFSET_ANCHOR.LEFT : OFFSET_ANCHOR.RIGHT;\n}\n\nexport function verifyIndex(size: number, index: number) {\n  index = normalizeIndex(size, index);\n  return index === size ? -1 : index;\n}\n\nexport function normalizeIndex(size: number, index: number): number {\n  return max(-1, min(size, index < 0 ? size + index : index));\n}\n\nexport function shiftDownRoundUp(value: number, shift: number): number {\n  var a = value >>> shift;\n  return a + ((a << shift) < value ? 1 : 0);\n}\n\nexport function modulo(value: number, shift: number): number {\n  return value & ((CONST.BRANCH_FACTOR << shift) - 1);\n}\n\nexport function concatSlotsToNewArray<T>(left: Slot<T>[], right: Slot<T>[]): Slot<T>[] {\n  var arr = new Array<Slot<T>>(left.length + right.length);\n  var sum = 0;\n  for(var i = 0; i < left.length; i++) {\n    arr[i] = left[i];\n    arr[i].sum = (sum += left[i].size);\n  }\n  for(var j = 0; j < right.length; i++, j++) {\n    arr[i] = right[j];\n    arr[i].sum = (sum += right[j].size);\n  }\n  return arr;\n}\n"]}